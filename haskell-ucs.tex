%% haskell-ucs.tex
%
% Copyright 2014  Rudy Matela
%
% This text is avaliable under (at your option):
%   * Creative Commons Attribution-ShareAlike 3.0 Licence
%   * GNU Free Documentation License version 1.3 or Later
%

\documentclass{refcard}

\renewcommand{\familydefault}{\sfdefault}

\title{Ultimate Haskell Cheat Sheet}

\cright{
	Copyright 2014, Rudy Matela --
	Compiled on \today{} --
	Upstream: \texttt{https://github.com/rudymatela/ultimate-cheat-sheets}
}{
	This text is avaliable under the Creative Commons Attribution-ShareAlike
	3.0 Licence, \textbf{or}, the GNU Free Documentation License version 1.3 or
	Later.
}


\begin{document}

\maketitle

\section{Structure}

\begin{verbatim}
	func :: type -> type
	func x = expr

	fung :: type -> [type] -> type
	fung x xs = expr

	main = do code
	          code
	          ...
\end{verbatim}


\section{Function Application}

\begin{tabular}{CC}
	\li[f x y] (f x) y
	\li[f x y z] ((f x) y) z
	\li[f g \$ h x] f g (h x)
	\li[f \$ g x y] f (g x y)
	\li[f \$ g \$ h x] f (g (h x))
	\li[(f . g . h) x] f (g (h x))
\end{tabular}


\section{Binding Types}

\begin{ldesc}
	\li[has type]               \I{expr}\s::\s\I{type}
	\li[boolean]                True || False :: Bool
	\li[character]              'a' :: Char
	\li[integer (32-bit)]       1 :: Int
	\li                         3 + 2 :: Int
	\li[integer (arbitrary sz.)]    31337 :: Integer
	\li                         31337\verb+^+10 :: Integer
	\li[single precision float] 1.2 :: Float 
	\li[double precision float] 1.2 :: Double
	\li[list]                   [] :: [a]
%	\li[]                       [1,2,3] :: [Integer]
	\li[]                       ['a','b','c'] :: [Char]
	\li                         "abc" :: [Char]
	\li[]                       [[1,2],[3,4]] :: [[Integer]]
	\li[tuple]                  (1,2) :: (Int,Int)
%	\li                         (1,'a') :: (Int,Char)
	\li                         ([1,2],'a') :: ([Int],Char)
	\li[string]                 "asdf" :: String
	\li[functions]              foo :: a -> a
	\li                         double :: Int -> Int
\end{ldesc}


\section{Binding Classes (Typeclasses)}

\begin{ldesc}
	\li[Numeric (+,-,*,/)]             137 :: Num a => a
	\li[Floating]                      1.2 :: Floating a => a
	\li[Fractional]                    1.2 :: Fractional a => a
	\li[Equatable (==)]                'a' :: Eq a => a
	\li[Ordered ($<=,>=,>,<$)]         731 :: Ord a => a
	\li                                sort :: 
	\li                                \s\s\s\s Ord a => [a] -> [a]
\end{ldesc}


\section{Declaring Types and Classes}

\begin{ldesc}
	\li[type synonym] type \I{MyType} = \I{Type} \li
	                  type UserId = Integer \li
					  type UserName = String \li
					  type User = (UserId,UserName) \li
					  type UserList = [User]
	\li[data \small{(single constructor)}]
		data\s\I{MyData}\s{}=\s\I{MyData}\s\I{Type}\s\I{Type}\s\I{Type} \li
		\s\s\s\s\s\s\s\s\s\s\s\s\s\s{}deriving (\I{Class},\I{Class})
	\li[data \small{(multi constructor)}]
		data\s\I{MyData}\s{}=\s{}\I{Simple} \I{Type} | \li
		\s\s\s\hphantom{\I{MyData}}\s\s\s\s\s{}\I{Duple} \I{Type} \I{Type} | \li
		\s\s\s\hphantom{\I{MyData}}\s\s\s\s\s{}\I{Nople}

	\li[typeclass] class \I{MyClass} a where \li
	               \s\s{}\I{foo}\s::\s{}a\s->\s{}a\s->\s{}\I{b} \li
	               \s\s{}\I{goo}\s::\s{}a\s->\s{}a \li
				   \s\s...
\end{ldesc}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[List index, function composition] !!, \hfill .
	\Li[raise to: Non-neg. Int, Int, Float] \hfill \verb+^+, \verb+^^+, \verb+**+
	\Li[multiplication, fractional division] *, /
	\li[integral division ($\Rightarrow -\infty$), modulus] `div`, `mod`
	\li[integral quotient ($\Rightarrow 0$), remainder] `quot`, `rem`
	\Li[addition, subtraction] +, -
	\Li[list construction, append lists] \hfill :, ++
	\Li[comparisons:]     \s>, >=, <, <=, ==, /=\s
	\li[list membership]  \s\s`elem`, `notElem`\s\s
	\Li[boolean and] \hfill \&\&
	\Li[boolean or] \hfill ||
	\Li[sequencing: bind and then] >>=, >>
	\Li[application, strict apl., sequencing] \$, \$!, seq
\end{Ldesc}

\noindent
NOTE: Highest precedence (first line) is 9, lowest precedence is 0.  Those
aligned to the right are right associative, all others left associative: except
boolean comparisons and list membership, which are non-associative.  Default is
\C{infixl 9}.

\subsubsection{Defining fixity}
\begin{ldesc}
	\li[non associative fixity] infix \I{0-9} \I{`op`}
	\li[left associative fixity] infixl \I{0-9} \I{+--+}
	\li[right associative fixity] infixr \I{0-9} \I{-!-}
	\li[default, implied when no fixity given] infixl 9
\end{ldesc}

\subsection{Functions $\equiv$ Infix operators}

\begin{tabular}{CC}
	\li[f a b]         a `f` b
	\li[a + b]         (+) a b
	\li[(a +) b]       ((+) a) b
	\li[(+ b) a]       (\verb+\x+ -> ((+) x b)) a
\end{tabular}


\section{Common functions}

\subsection{Lists {\normalsize (and Strings {\small(which are lists...)})}}

\begin{ldesc}
	\li[size / length of \C{xs}]         length xs
	\li[invert / reverse of \C{xs}]      reverse xs
	\li[head / first element of \C{xs}]  head xs
	\li[checks for \C{x} in \C{xs}]      x `elem` xs \li
	                                     elem x xs
	\li[sorts \C{xs}]                    sort xs
	\li                                  \s\s:: Ord a => [a]
	\li[pairs of elements from xs and ys] zip xs ys \li
										 \s\s:: [a] -> [b] -> [(a, b)]
\end{ldesc}

\subsection{Tuples}

\begin{ldesc}
	\li[first of pair \C{p}]             fst p
	\li[second of pair \C{p}]            snd p
	\li[swap pair p]                     swap p
\end{ldesc}


\subsection{Higher-order / Functors}

\newcommand{\emptyarray}{[]}
\begin{ldesc}
	\li[apply f for each x in xs]   map f xs
	\li[\s\s returning new list]    \s\s:: (a -> b) -> [a] -> [b]
	\li[fold - (z + left) `to` right]   foldl f z xs \li
										\s\s\small{}:: (a -> b -> a) -> a -> [b] -> a
	\li[fold - right `to` (left + z)]   foldr f z xs \li
										\s\s\small{}:: (a -> b -> b) -> b -> [a] -> b
	\li[filter all xs satisfying p xs]  filter p xs \li
	                                    \s\s\small{}:: (a -> Bool) -> [a] -> [a]
\end{ldesc}


\subsection{IO \normalsize -- Must be ``inside'' the IO Monad}

\begin{ldesc}
	\li[Write char \C{c} to stdout]                      putChar c
	\li[Write string \C{cs} to stdout]                   putStr cs
	\li[... \C{cs} ... with a newline]                   putStrLn cs
	\li[Print \C{x}, a \C{show} instance$^2$, to stdout] print x
	\li[Read char from stdin]                            getChar
	\li[Read line from stdin as a string]                getLine
	\li[Read all input from stdin as a string]           getContents
	\li[Make foo process the input]                      interact foo \li
	                                                     \s\s\small{}:: (String -> String) -> IO ()
	\li[Write char \C{c} to channel/file \C{h}]          hPutChar h c
	\li[Write string \C{cs} to channel/file \C{h}]       hPutStr h cs
	\li[... \C{cs} ... with a newline ... to \C{h}]      hPutStrLn h cs
\end{ldesc}


\vspace{35mm} % Pragma, move pattern matching to next page


\section{Pattern Matching}


\subsection{List Pattern Matching}

\begin{ldesc}
	\li[head \C{x} and tail \C{xs}]  (x:xs)
	\li[empty list]                  []
	\li[list with 3 elements \C{a}, \C{b} and \C{c}]  [a,b,c]
	\li[list with 3 elements \C{a}, \C{b} and \C{c}]  (a:b:c:[])
	\li[list where 2nd element is 3] (x:3:xs)
\end{ldesc}


\subsection{Other Types Pattern Matching}

\begin{ldesc}
	\li[pair values \C{a} and \C{b}]           (a,b)
	\li[triple values \C{a}, \C{b} and \C{c}]  (a,b,c)
	\li[just constructor]                      Just a
	\li[nothing constructor]                   Nothing
	\li[user-defined type]                     MyData a b c
\end{ldesc}


\subsection{Wildcard Pattern ``Matching''}

\begin{ldesc}
	\li[ignore value]                      \verb+_+
	\li[ignore first elements of list]     (\verb+_+:xs)
	\li[ignore second element of tuple]    (a,\verb+_+)
	\li[ignore one of the ``componenet'']  MyData a \verb+_+ c
\end{ldesc}


\subsection{Nested Pattern}

\begin{ldesc}
	\li[match first tuple on list]  ((a,b):xs)
	\li[match list inside tuple]    (xs,y:ys,zs)
\end{ldesc}


\subsection{As-pattern}

\begin{ldesc}
	\li[match entire tuple \C{s} its values \C{a,b}]            s@(a,b)
	\li[match entire list \C{a} its head \C{x} and tail \C{xs}] a@(x:xs)
	\li[entire data \C{p} and ``components'']                   p@(MyData a b c)
\end{ldesc}



\section{List Comprehensions}

\begin{ldesc}
	\li[pairs where sum=4] [(x,y) | \li
	                       \s\s{}x <- [0..4], \li
						   \s\s{}y <- [0..4], \li
						   \s\s{}x + y == 4] \li
	                       == [(0,4),(1,3),(2,2),...]
\end{ldesc}


\vspace{45mm} % Pragma, move list comprehensions to next column


\section{Expressions (Eval. control)}

\begin{ldesc}
	\li[statement separator]         ;\s\s\s\s-- or line break
	\li[statement grouping]          \verb+{ }+\s\s-- or layout/indentation
	\li
	\li[if expression]
		if\s\I{expr}\s\textcolor{gray}{::\s{}Bool} \li
		\s\s{}then\s\I{expr} \textcolor{gray}{::\s{}a} \li
		\s\s{}else\s\I{expr} \textcolor{gray}{::\s{}a} \li

	\li[case expression]
		case\s\I{expr}\s{}of     \li
		\s\s{}\I{pat}\s->\s{}\I{expr}   \li
		\s\s{}\I{pat}\s->\s{}\I{expr}   \li
		\s\s... \li
		\s\s{}\I{\_}\s->\s{}\I{expr}   \li

	\li[let expression]
		let\s\I{name}=\I{expr} \li
		\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s... \li
		in\s\I{expr} \li

	\li[where notation]
		\I{expr} \li
		where\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s... \li

	\li[do notation]
		do      \I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}\I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}... \li

	\li[pattern matching]
		f\s::\s{}a -> b -> c \li[\s{}\I{(case sugar)}]
		f pat pat = expr \li
		f \verb+_+\s\s{} pat = expr \li
		f pat \verb+_+\s\s{} = expr \li
		f \verb+_+\s\s{} \verb+_+\s\s{} = expr
\end{ldesc}


\section{Libraries / Modules}

\begin{ldesc}
	\li[importing]              import \I{PathTo.Lib}
	\li[importing (qualified)]  import \I{PathTo.Lib} as \I{PL}
	\li[importing (subset)]     import \I{PathTo.Lib} (\I{foo},\I{goo})
	\li[declaring]
		module \I{Module.Name} \li
		\s\s( \I{foo} \li
		\s\s, \I{goo} \li
		\s\s) \li
		where \li
	    ... \li
	\li[./File/On/Disk.hs] import File.On.Disk
\end{ldesc}


\subsection{QuickCheck \hfill \C{Test.Quickcheck}}

\begin{ldesc}
	\li[declaring property]
		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Bool \li
		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Property
	\li[verifying property]
		quickCheck \I{prop\_something}
\end{ldesc}

\subsection{SmallCheck \hfill \C{Test.SmallCheck}}

\begin{ldesc}
	\li[verifying property]
		smallCheck \I{depth} \I{prop\_something}
\end{ldesc}


\subsection{HUnit \hfill \C{Test.HUnit}}

\begin{ldesc}
	\li[equality assertion] \I{expected} \~{}=?\s\I{actual}
	\li[testlist]           \I{mytestlist} = \li
							\s\s{}TestList\s{}[ \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s... \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} ]
	\li[running tests]      runTestTT \I{mytestlist}
\end{ldesc}


\section{GHC - Glasgow Haskell Compiler}

\begin{ldesc}
	\li[compiling \C{program.hs}] \$ ghc program.hs
	\li[running]                  \$ ./program
	\li[running directly]         \$ run\_haskell program.hs
	\li[interactive mode (GHCi)]  \$ ghci
	\li[GHCi load]                \verb+>+ :l \I{program.hs}
	\li[GHCi reload]              \verb+>+ :r \I{program.hs}
	\li[GHCi activate stats]      \verb+>+ :set +s
	\li[GHCi turn off stats]      \verb+>+ :unset +s
	\li[GHCi help]                \verb+>+ :?
	\li[Type of an expression]    \verb+>+ :t \I{expr}
	\li[Info (oper./func./class)] \verb+>+ :i \I{thing}
\end{ldesc}

\end{document} 

