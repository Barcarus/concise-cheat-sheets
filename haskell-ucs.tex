%% haskell-ucs.tex
%
% Copyright 2014  Rudy Matela
%
% This text is avaliable under (at your option):
%   * Creative Commons Attribution-ShareAlike 3.0 Licence
%   * GNU Free Documentation License version 1.3 or Later
%

\documentclass{refcard}

\renewcommand{\familydefault}{\sfdefault}

\title{Ultimate Haskell Cheat Sheet}

\cright{
	Copyright 2014, Rudy Matela --
	Compiled on \today{} --
	Upstream: \texttt{https://github.com/rudymatela/ultimate-cheat-sheets}
}{
	This text is avaliable under the Creative Commons Attribution-ShareAlike
	3.0 Licence, \textbf{or}, the GNU Free Documentation License version 1.3 or
	Later.
}


\begin{document}

\maketitle

\section{Structure}

\begin{verbatim}
	func :: type -> type
	func x = expr

	fung :: type -> [type] -> type
	fung x xs = expr

	main = do code
	          code
	          ...
\end{verbatim}


\section{Function Application}

\begin{tabular}{CC}
	\li[f a b] (f a) b
	\li[f a b c] ((f a) b) c
	\li[f g \$ h x] f g (h x)
	\li[f \$ g x y] f (g x y)
	\li[f \$ g \$ h x] f (g (h x))
	\li[(f . g . h) x] f (g (h x))
\end{tabular}


\section{Binding Types}

\begin{ldesc}
	\li[has type]               \I{expr}\s::\s\I{type}
	\li[boolean]                True || False :: Bool
	\li[character]              'a' :: Char
	\li[integer (32-bit)]       1 :: Int
	\li                         3 + 2 :: Int
	\li[integer (arbitrary sz.)]    31337 :: Integer
	\li                         31337\verb+^+10 :: Integer
	\li[single precision float] 1.2 :: Float 
	\li[double precision float] 1.2 :: Double
	\li[list]                   [] :: [a]
%	\li[]                       [1,2,3] :: [Integer]
	\li[]                       ['a','b','c'] :: [Char]
	\li                         "abc" :: [Char]
	\li[]                       [[1,2],[3,4]] :: [[Integer]]
	\li[tuple]                  (1,2) :: (Int,Int)
%	\li                         (1,'a') :: (Int,Char)
	\li                         ([1,2],'a') :: ([Int],Char)
	\li[string]                 "asdf" :: String
	\li[functions]              foo :: a -> a
	\li                         double :: Int -> Int
\end{ldesc}


\section{Binding Classes (Typeclasses)}

\begin{ldesc}
	\li[Numeric (+,-,*,/)]             137 :: Num a => a
	\li[Floating]                      1.2 :: Floating a => a
	\li[Fractional]                    1.2 :: Fractional a => a
	\li[Equatable (==)]                'a' :: Eq a => a
	\li[Ordered ($<=,>=,>,<$)]         731 :: Ord a => a
	\li                                sort :: 
	\li                                \s\s\s\s Ord a => [a] -> [a]
\end{ldesc}


\section{Declaring Types and Classes}

\begin{ldesc}
	\li[data] Data Etc = Etc | Etc | Etc
	\li[type] Type ...
	\li[class] ...
\end{ldesc}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[List index, function composition] !!, \hfill .
	\Li[raise to: Non-neg. Int, Int, Float] \hfill \verb+^+, \verb+^^+, \verb+**+
	\Li[multiplication, fractional division] *, /
	\li[integral division ($\Rightarrow -\infty$), modulus] `div`, `mod`
	\li[integral quotient ($\Rightarrow 0$), remainder] `quot`, `rem`
	\Li[addition, subtraction] +, -
	\Li[list construction, append lists] \hfill :, ++
	\Li[comparisons: relative] >, >=, <, <=
	\li[comparisons: equality] ==, /=
	\li[list membership] `elem`, `notElem`
	\Li[boolean and] \hfill \&\&
	\Li[boolean or] \hfill ||
	\Li[sequencing: bind and then] >>=, >>
	\Li[application, strict apl., sequencing] \$, \$!, seq
\end{Ldesc}

\noindent
NOTE: Highest precedence (first line) is 9, lowest precedence is 0.  Those
aligned to the right are right associative, all others left associative: except
boolean comparisons and list membership, which are non-associative.  Default is
\C{infixl 9}.

\subsubsection{Defining fixity}
\begin{ldesc}
	\li[non associative fixity] infix \I{0-9} \I{`op`}
	\li[left associative fixity] infixl \I{0-9} \I{+--+}
	\li[right associative fixity] infixr \I{0-9} \I{-!-}
	\li[default, implied when no fixity given] infixl 9
\end{ldesc}


\section{Common functions}

\subsection{Lists {\small (and Strings {\tiny(which are lists...)})}}

\begin{ldesc}
	\li[size / length of \C{xs}]         length xs
	\li[invert / reverse of \C{xs}]      reverse xs
	\li[head / first element of \C{xs}]  head xs
	\li[checks for \C{x} in \C{xs}]      x `elem` xs \li
	                                     elem x xs
	\li[sorts \C{xs}]                    sort xs
	\li                                  \s\s:: Ord a => [a]
	\li[all pairs of two lists]          zip xs ys ps \li
										 \s\s:: [a] -> [b] -> [(a, b)]
\end{ldesc}

\subsection{Tuples}

\begin{ldesc}
	\li[first of pair \C{p}]             fst p
	\li[second of pair \C{p}]            snd p
\end{ldesc}


\subsection{Higher-order / Functors}

\newcommand{\emptyarray}{[]}
\begin{ldesc}
	\li[apply f for each x in xs]   map f xs
	\li[\s\s returning new list]    \s\s:: (a -> b) -> [a] -> [b]
	\li[fold - (z + left) `to` right]   foldl f z xs \li
										\s\s\small{}:: (a -> b -> a) -> a -> [b] -> a
	\li[fold - right `to` (left + z)]   foldr f z xs \li
										\s\s\small{}:: (a -> b -> b) -> b -> [a] -> b
	\li[filter all xs satisfying p xs]  filter p xs \li
	                                    \s\s\small{}:: (a -> Bool) -> [a] -> [a]
\end{ldesc}


\section{Expressions (Eval. control)}

\begin{ldesc}
	\li[statement separator]         ;\s\s\s\s-- or line break
	\li[statement grouping]          \verb+{ }+\s\s-- or layout/indentation
	\li
	\li[if expression]
		if\s\I{expr}\s\textcolor{gray}{::\s{}Bool} \li
		\s\s{}then\s\I{expr} \textcolor{gray}{::\s{}a} \li
		\s\s{}else\s\I{expr} \textcolor{gray}{::\s{}a} \li

	\li[case expression]
		case\s\I{expr}\s{}of     \li
		\s\s{}\I{expr}\s->\s{}\I{expr}   \li
		\s\s{}\I{expr}\s->\s{}\I{expr}   \li
		\s\s... \li
		\s\s{}\I{\_}\s->\s{}\I{expr}   \li

	\li[let expression]
		let\s\I{name}=\I{expr} \li
		\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s... \li
		in\s\I{expr} \li

	\li[where notation]
		\I{expr} \li
		where\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s... \li

	\li[do notation]
		do      \I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}\I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}... \li

	\li[pattern matching]
		f\s::\s{}a -> b -> c \li[\s{}\I{(case sugar)}]
		f expr expr = expr \li
		f \verb+_+\s\s\s{} expr = expr \li
		f expr \verb+_+\s\s\s{} = expr \li
		f \verb+_+\s\s\s{} \verb+_+\s\s\s{} = expr
\end{ldesc}


\section{List Comprehensions}

\begin{ldesc}
	\li[pairs where sum=4] [(x,y) | \li
	                       \s\s{}x <- [0..4], \li
						   \s\s{}y <- [0..4], \li
						   \s\s{}x + y == 4] \li
	                       == [(0,4),(1,3),(2,2),...]
\end{ldesc}


\section{Libraries / Modules}

\begin{ldesc}
	\li[importing]              import \I{PathTo.Lib}
	\li[importing (qualified)]  import \I{PathTo.Lib} as \I{PL}
	\li[importing (subset)]     import \I{PathTo.Lib} (\I{foo},\I{goo})
	\li[declaring]
		module \I{Module.Name} \li
		\s\s( \I{foo} \li
		\s\s, \I{goo} \li
		\s\s) \li
		where \li
	    ... \li
	\li[./File/On/Disk.hs] import File.On.Disk
\end{ldesc}


\subsection{QuickCheck \hfill \C{Test.Quickcheck}}

\begin{ldesc}
	\li[declaring property]
		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Bool \li
		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Property
	\li[verifying property]
		quickCheck \I{prop\_something}
\end{ldesc}

\subsection{SmallCheck \hfill \C{Test.SmallCheck}}

\begin{ldesc}
	\li[verifying property]
		smallCheck \I{depth} \I{prop\_something}
\end{ldesc}


\subsection{HUnit \hfill \C{Test.HUnit}}

\begin{ldesc}
	\li[equality assertion] \I{expected} \~{}=?\s\I{actual}
	\li[testlist]           \I{mytestlist} = \li
							\s\s{}TestList\s{}[ \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s... \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} ]
	\li[running tests]      runTestTT \I{mytestlist}
\end{ldesc}


\section{GHC - Glasgow Haskell Compiler}

\begin{ldesc}
	\li[compiling \C{program.hs}] \$ ghc program.hs
	\li[running]                  \$ ./program
	\li[running directly]         \$ run\_haskell program.hs
	\li[interactive mode (GHCi)]  \$ ghci
	\li[GHCi load]                \verb+>+ :l \I{program.hs}
	\li[GHCi reload]              \verb+>+ :r \I{program.hs}
	\li[GHCi activate stats]      \verb+>+ :set +s
	\li[GHCi turn off stats]      \verb+>+ :unset +s
	\li[GHCi help]                \verb+>+ :?
	\li[Type of an expression]    \verb+>+ :t \I{expr}
	\li[Info (oper./func./class)] \verb+>+ :info \I{thing}
\end{ldesc}

\end{document} 

