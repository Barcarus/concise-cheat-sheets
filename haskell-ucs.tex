\documentclass{refcard}

\renewcommand{\familydefault}{\sfdefault}

\title{Ultimate Haskell Cheat Sheet}

\begin{document}

\maketitle

\section{Structure}

\begin{verbatim}
	func :: type -> type
	func x = expr

	fung :: type -> [type] -> type
	func x xs = expr

	main = do code
	          code
	          ...
\end{verbatim}


\section{Binding Types}

\begin{ldesc}
	\li[has type]               \I{expr}\s::\s\I{type}
	\li[boolean]                True :: Bool
	\li                         False :: Bool
	\li[character]              'a' :: Char
	\li[integer (32-bit)]       1 :: Int
	\li                         3 + 2 :: Int
	\li[integer (arbitrary)]    31337 :: Integer
	\li                         31337\verb+^+10 :: Integer
	\li[single precision float] 1.2 :: Float 
	\li[double precision float] 1.2 :: Double
	\li[list]                   [] :: [a]
	\li[]                       [1,2,3] :: [Integer]
	\li[]                       ['a','b','c'] :: [Char]
	\li                         "abc" :: [Char]
	\li[]                       [[1,2],[3,4]] :: [[Integer]]
	\li[tuple]                  (1,2) :: (Int,Int)
	\li                         (1,'a') :: (Int,Char)
	\li                         ([1,2],'a') :: ([Int],Char)
	\li[string]                 "asdf" :: String
	\li[functions]              foo :: a -> a
	\li                         double :: Int -> Int
\end{ldesc}


\section{Binding Classes (Typeclasses)}

\begin{ldesc}
	\li[Numeric (+,-,*,/)]             137 :: Num a => a
	\li[Floating]                      1.2 :: Floating a => a
	\li[Fractional]                    1.2 :: Fractional a => a
	\li[Equatable (==)]                'a' :: Eq a => a
	\li[Ordered ($<=,>=,>,<$)]         731 :: Ord a => a
	\li                                sort :: 
	\li                                \s\s\s\s Ord a => [a] -> [a]
\end{ldesc}


\section{Declaring Types and Classes}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[9] .
	\Li[8] **, \verb+^+
	\Li[7] *, /, `div`, `mod`
	\Li[6] +, -
	\Li[5] ++, :
	\Li[4] `elem`
	\li[4] >, >=, <, <=
	\li[4] ==, /=
	\Li[3] \&\&
	\Li[2] ||
	\Li[1] >>=, >>
	\Li[0] \$
\end{Ldesc}

\noindent
Note, default is infixl 9.  See section 4.4 of the Haskell Report.


\section{Common functions}

\subsection{Lists {\small (and Strings {\tiny(which are lists...)})}}

\begin{ldesc}
	\li[size / length of \C{xs}]         length xs
	\li[invert / reverse of \C{xs}]      reverse xs
	\li[head / first element of \C{xs}]  head xs
	\li[checks for \C{x} in \C{xs}]      x `elem` xs
	                                     elem x xs
	\li[sorts \C{xs}]                    sort xs
	\li                                  (xs :: Ord a => [a])
\end{ldesc}

\subsection{Tuples}

\begin{ldesc}
	\li[first of pair \C{p}]             fst p
	\li[second of pair \C{p}]            snd p
\end{ldesc}


\subsection{High Order Functions}

\newcommand{\emptyarray}{[]}
\begin{ldesc}
	\li[apply f for each x in xs]   map f xs
	\li[\s\s returning new list]    \s\s:: (a -> b) -> [a] -> [b]
	\li[$x_1:x_2:...:\emptyarray \Rightarrow \backslash$]  foldl (+) n xs
	\li[$x_1 + x_2 + ... + n$]                             \s\s\footnotesize :: (a -> b -> a) -> b -> [a] -> b
\end{ldesc}


\section{Control Flow}

\begin{ldesc}
	\li[statement terminator]        ;
	\li[block delimiter]             \{ ] or [ \}
	\li[exit from while]             brk
	\li[next while iteration]        cnt
	\li[return value from function]  return \I{expr}
\end{ldesc}


\subsection{Flow Constructions}

\begin{ldesc}
	\li[if statement]
		if\s(\I{expr})\s\I{block}     \li
		else\s\s\s\s\s\s\s\s\I{block} \li
	
	\li[do notation] do ...

	\li[while statement]
		while (\I{expr}) \{           \li
		\s\s\s\s\I{statement};        \li
		\s\s\s\s\I{statement};        \li
	    \}
\end{ldesc}


\section{List Comprehensions}


\section{Libraries / Modules}

\begin{ldesc}
	\li[importing]              import \I{PathTo.Lib}
	\li[importing (qualified)]  import \I{PathTo.Lib} as \I{PL}
	\li[importing (subset)]     import \I{PathTo.Lib} (\I{foo},\I{goo})
	\li[declaring]
		module \I{Module.Name} \li
		\s\s( \I{foo}
		\s\s, \I{goo}
		\s\s) \li
		where \li
	 	\li
	    ...
	\li[./File/On/Disk.hs] import File.On.Disk
\end{ldesc}


\subsection{QuickCheck \hfill \C{Test.Quickcheck}}

\begin{ldesc}
	\li[iiii] iiii
	\li[wwww] wwww
\end{ldesc}

\subsection{SmallCheck \hfill \C{Test.SmallCheck}}

\begin{ldesc}
	\li[iiii] iiii
	\li       wwww
	\li[blah] blah
\end{ldesc}


\subsection{HUnit \hfill \C{Test.HUnit}}

\begin{ldesc}
	\li[printing] print "formatstring"
	\li[wwww] wwww
	\li[iiii] wwww
	\li       wwww
	\li[blah] blah
\end{ldesc}


\section{GHC - Glasgow Haskell Compiler}

\begin{ldesc}
	\li[compiling \C{program.hs}] \$ ghc program.hs
	\li[running]                  \$ ./program
	\li[running directly]         \$ run\_haskell program.hs
	\li[interactive mode (GHCi)]  \$ ghci
	\li[GHCi load]                \verb+>+ :l \I{program.hs}
	\li[GHCi reload]              \verb+>+ :r \I{program.hs}
	\li[GHCi activate stats]      \verb+>+ :set +s
	\li[GHCi turn off stats]      \verb+>+ :unset +s
	\li[GHCi help]                \verb+>+ :?
	\li[Type of an expression]    \verb+>+ :t \I{expr}
	\li[Info (oper./func./class)] \verb+>+ :info \I{oper/func/clss}
\end{ldesc}


\end{document} 

