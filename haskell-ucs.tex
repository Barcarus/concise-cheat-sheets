%% haskell-ucs.tex
%
% Copyright 2014  Rudy Matela
%
% This text is avaliable under (at your option):
%   * Creative Commons Attribution-ShareAlike 3.0 Licence
%   * GNU Free Documentation License version 1.3 or Later
%

\documentclass{refcard}

\renewcommand{\familydefault}{\sfdefault}

\title{Ultimate Haskell Cheat Sheet}

\cright{
	Copyright 2014, Rudy Matela
}{
	This text is avaliable under the Creative Commons Attribution-ShareAlike
	3.0 Licence, \textbf{or}, the GNU Free Documentation License version 1.3 or
	Later.
}


\begin{document}

\maketitle

\section{Structure}

\begin{verbatim}
	func :: type -> type
	func x = expr

	fung :: type -> [type] -> type
	func x xs = expr

	main = do code
	          code
	          ...
\end{verbatim}


\section{Function Application}

\begin{tabular}{CC}
	\li[f a b] (f a) b
	\li[f a b c] ((f a) b) c
	\li[f g \$ h x] f g (h x)
	\li[f \$ g x y] f (g x y)
	\li[f \$ g \$ h x] f (g (h x))
	\li[(f . g . h) x] f (g (h x))
\end{tabular}


\section{Binding Types}

\begin{ldesc}
	\li[has type]               \I{expr}\s::\s\I{type}
	\li[boolean]                True || False :: Bool
	\li[character]              'a' :: Char
	\li[integer (32-bit)]       1 :: Int
	\li                         3 + 2 :: Int
	\li[integer (arbitrary sz.)]    31337 :: Integer
	\li                         31337\verb+^+10 :: Integer
	\li[single precision float] 1.2 :: Float 
	\li[double precision float] 1.2 :: Double
	\li[list]                   [] :: [a]
%	\li[]                       [1,2,3] :: [Integer]
	\li[]                       ['a','b','c'] :: [Char]
	\li                         "abc" :: [Char]
	\li[]                       [[1,2],[3,4]] :: [[Integer]]
	\li[tuple]                  (1,2) :: (Int,Int)
%	\li                         (1,'a') :: (Int,Char)
	\li                         ([1,2],'a') :: ([Int],Char)
	\li[string]                 "asdf" :: String
	\li[functions]              foo :: a -> a
	\li                         double :: Int -> Int
\end{ldesc}


\section{Binding Classes (Typeclasses)}

\begin{ldesc}
	\li[Numeric (+,-,*,/)]             137 :: Num a => a
	\li[Floating]                      1.2 :: Floating a => a
	\li[Fractional]                    1.2 :: Fractional a => a
	\li[Equatable (==)]                'a' :: Eq a => a
	\li[Ordered ($<=,>=,>,<$)]         731 :: Ord a => a
	\li                                sort :: 
	\li                                \s\s\s\s Ord a => [a] -> [a]
\end{ldesc}


\section{Declaring Types and Classes}

\begin{ldesc}
	\li[data] Data Etc = Etc | Etc | Etc
	\li[type] Type ...
	\li[class] ...
\end{ldesc}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[List index, function composition] !!, \hfill .
	\Li[raise to: Non-neg. Int, Int, Float] \hfill \verb+^+, \verb+^^+, \verb+**+
	\Li[multiplication, fractional division] *, /
	\li[integral division ($\Rightarrow -\infty$), modulus] `div`, `mod`
	\li[integral quotient ($\Rightarrow 0$), remainder] `quot`, `rem`
	\Li[addition, subtraction] +, -
	\Li[list construction, append lists] \hfill :, ++
	\Li[comparisons: relative] >, >=, <, <=
	\li[comparisons: equality] ==, /=
	\li[list membership] `elem`, `notElem`
	\Li[boolean and] \hfill \&\&
	\Li[boolean or] \hfill ||
	\Li[sequencing: bind and then] >>=, >>
	\Li[application, strict apl., sequencing] \$, \$!, seq
\end{Ldesc}

\noindent
NOTE: Highest precedence (first line) is 9, lowest precedence is 0.  Those
aligned to the right are right associative, all others left associative: except
boolean comparisons and list membership, which are non-associative.  Default is
\C{infixl 9}.

\subsubsection{Defining fixity}
\begin{ldesc}
	\li[non associative fixity] infix \I{0-9} \I{`op`}
	\li[left associative fixity] infixl \I{0-9} \I{+--+}
	\li[right associative fixity] infixr \I{0-9} \I{-!-}
	\li[default, implied when no fixity given] infixl 9
\end{ldesc}


\section{Common functions}

\subsection{Lists {\small (and Strings {\tiny(which are lists...)})}}

\begin{ldesc}
	\li[size / length of \C{xs}]         length xs
	\li[invert / reverse of \C{xs}]      reverse xs
	\li[head / first element of \C{xs}]  head xs
	\li[checks for \C{x} in \C{xs}]      x `elem` xs
	                                     elem x xs
	\li[sorts \C{xs}]                    sort xs
	\li                                  (xs :: Ord a => [a])
\end{ldesc}

\subsection{Tuples}

\begin{ldesc}
	\li[first of pair \C{p}]             fst p
	\li[second of pair \C{p}]            snd p
\end{ldesc}


\subsection{High Order Functions}

\newcommand{\emptyarray}{[]}
\begin{ldesc}
	\li[apply f for each x in xs]   map f xs
	\li[\s\s returning new list]    \s\s:: (a -> b) -> [a] -> [b]
	\li[$x_1:x_2:...:\emptyarray \Rightarrow \backslash$]  foldl (+) n xs
	\li[$x_1 + x_2 + ... + n$]                             \s\s\footnotesize :: (a -> b -> a) -> b -> [a] -> b
\end{ldesc}


\section{Control Flow}

\begin{ldesc}
	\li[statement terminator]        ;
	\li[block delimiter]             \{ ] or [ \}
	\li[exit from while]             brk
	\li[next while iteration]        cnt
	\li[return value from function]  return \I{expr}
\end{ldesc}


\subsection{Flow Constructions}

\begin{ldesc}
	\li[if statement]
		if\s(\I{expr})\s\I{block}     \li
		else\s\s\s\s\s\s\s\s\I{block} \li
	
	\li[do notation] do ...

	\li[while statement]
		while (\I{expr}) \{           \li
		\s\s\s\s\I{statement};        \li
		\s\s\s\s\I{statement};        \li
	    \}
\end{ldesc}


\section{List Comprehensions}

\begin{ldesc}
	\li[etc] etc
\end{ldesc}


\section{Libraries / Modules}

\begin{ldesc}
	\li[importing]              import \I{PathTo.Lib}
	\li[importing (qualified)]  import \I{PathTo.Lib} as \I{PL}
	\li[importing (subset)]     import \I{PathTo.Lib} (\I{foo},\I{goo})
	\li[declaring]
		module \I{Module.Name} \li
		\s\s( \I{foo}
		\s\s, \I{goo}
		\s\s) \li
		where \li
	 	\li
	    ...
	\li[./File/On/Disk.hs] import File.On.Disk
\end{ldesc}


\subsection{QuickCheck \hfill \C{Test.Quickcheck}}

\begin{ldesc}
	\li[iiii] iiii
	\li[wwww] wwww
\end{ldesc}

\subsection{SmallCheck \hfill \C{Test.SmallCheck}}

\begin{ldesc}
	\li[iiii] iiii
	\li       wwww
	\li[blah] blah
\end{ldesc}


\subsection{HUnit \hfill \C{Test.HUnit}}

\begin{ldesc}
	\li[printing] print "formatstring"
	\li[wwww] wwww
	\li[iiii] wwww
	\li       wwww
	\li[blah] blah
\end{ldesc}


\section{GHC - Glasgow Haskell Compiler}

\begin{ldesc}
	\li[compiling \C{program.hs}] \$ ghc program.hs
	\li[running]                  \$ ./program
	\li[running directly]         \$ run\_haskell program.hs
	\li[interactive mode (GHCi)]  \$ ghci
	\li[GHCi load]                \verb+>+ :l \I{program.hs}
	\li[GHCi reload]              \verb+>+ :r \I{program.hs}
	\li[GHCi activate stats]      \verb+>+ :set +s
	\li[GHCi turn off stats]      \verb+>+ :unset +s
	\li[GHCi help]                \verb+>+ :?
	\li[Type of an expression]    \verb+>+ :t \I{expr}
	\li[Info (oper./func./class)] \verb+>+ :info \I{oper/func/clss}
\end{ldesc}

\end{document} 

