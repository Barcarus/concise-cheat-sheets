%% haskell-ucs.tex
%
% Copyright 2014  Rudy Matela
%
% This text is avaliable under (at your option):
%   * Creative Commons Attribution-ShareAlike 3.0 Licence
%   * GNU Free Documentation License version 1.3 or Later
%

\documentclass{refcard}

\renewcommand{\familydefault}{\sfdefault}

\title{Ultimate Haskell Cheat Sheet}

\cright{
	Copyright 2014, Rudy Matela --
	Compiled on \today{} --
	Upstream: \texttt{https://github.com/rudymatela/ultimate-cheat-sheets}
}{
	This text is avaliable under the Creative Commons Attribution-ShareAlike
	3.0 Licence, \textbf{or}, the GNU Free Documentation License version 1.3 or
	Later.
}


\begin{document}

\maketitle

\section{Structure}

\begin{verbatim}
	func :: type -> type
	func x = expr

	fung :: type -> [type] -> type
	fung x xs = expr

	main = do code
	          code
	          ...
\end{verbatim}


\section{Function Application}

\begin{tabular}{CCC}
	\li[f x y]         (f x) y
	\li[f x y z]       ((f x) y) z
	\li[f g \$ h x]    f g (h x)
	\li[f \$ g x y]    f (g x y)
	\li[f \$ g \$ h x] f (g (h x))
	\li[(f~.~g~.~h) x] f (g (h x)) & f~.~g~.~h~\$~x
\end{tabular}


\section{Types}

\begin{tabular}{lCC}
	\li[has type]               \I{expr}         & ::~\I{type}
	\li[boolean]                True || False    & ::~Bool
	\li[character]              'a'              & ::~Char
	\li[fixed-precision integer] 1               & ::~Int
	\li[integer (arbitrary sz.)] 31337           & ::~Integer
	\li                          31337\verb+^+10 & ::~Integer
	\li[single precision float] 1.2              & ::~Float 
	\li[double precision float] 1.2              & ::~Double
	\li[list]                   []               & ::~[a]
	\li[]                       [1,2,3]          & ::~[Integer]
	\li[]                       ['a','b','c']    & ::~[Char]
	\li                         "abc"            & ::~[Char]
	\li[]                       [[1,2],[3,4]]    & ::~[[Integer]]
	\li[string]                 "asdf"           & ::~String
	\li[tuple]                  (1,2)            & ::~(Int,Int)
	\li                         (1,'a')          & ::~(Int,Char)
	\li                         ([1,2],'a')      & ::~([Int],Char)
%	\li[function]               $\backslash$x -> x & ::~a -> a
%	\li                         double           & ::~Int -> Int
\end{tabular}


\section{Binding Classes (Typeclasses)}

\begin{ldesc}
	\li[Numeric (+,-,*,/)]             137 :: Num a => a
	\li[Floating]                      1.2 :: Floating a => a
	\li[Fractional]                    1.2 :: Fractional a => a
	\li[Equatable (==)]                'a' :: Eq a => a
	\li[Ordered ($<=,>=,>,<$)]         731 :: Ord a => a
	\li                                sort :: Ord a => [a] -> [a]
	\li[Bounded (minBound,maxBound)]   minBound ::\s{}Int
\end{ldesc}


\section{Declaring Types and Classes}

\begin{ldesc}
	\li[type synonym] type \I{MyType} = \I{Type} \li
	                  type UserId = Integer \li
					  type UserName = String \li
					  type User = (UserId,UserName) \li
					  type UserList = [User]
	\li[data \small{(single constructor)}]
		data~\I{MyData}~{}=~\I{MyData}~\I{Type}~\I{Type}~\I{Type} \li
		~~~~~~~~~~~~~~{}deriving (\I{Class},\I{Class})
	\li[data \small{(multi constructor)}]
		data~\I{MyData}~{}=~{}\I{Simple} \I{Type} | \li
		~~~\hphantom{\I{MyData}}~~~~~{}\I{Duple} \I{Type} \I{Type} | \li
		~~~\hphantom{\I{MyData}}~~~~~{}\I{Nople}

	\li[typeclass] class \I{MyClass} a where \li
	               ~~{}\I{foo}~::~{}a~->~{}a~->~{}\I{b} \li
	               ~~{}\I{goo}~::~{}a~->~{}a \li
				   ~~...
\end{ldesc}


\section{Operators (grouped by precedence)}

\begin{Ldesc}
	\Li[List index, function composition] !!, \hfill .
	\Li[raise to: Non-neg. Int, Int, Float] \hfill \verb+^+, \verb+^^+, \verb+**+
	\Li[multiplication, fractional division] *, /
	\li[integral division ($\Rightarrow -\infty$), modulus] `div`, `mod`
	\li[integral quotient ($\Rightarrow 0$), remainder] `quot`, `rem`
	\Li[addition, subtraction] +, -
	\Li[list construction, append lists] \hfill :, ++
	\li[list difference]                 \s\s\s\s\s\s\s\s\s\s\s\s\verb+\\+
	\Li[comparisons:]     \s\s>, >=, <, <=, ==, /=\s\s
	\li[list membership]  \s\s\s`elem`, `notElem`\s\s\s
	\Li[boolean and] \hfill \&\&
	\Li[boolean or] \hfill ||
	\Li[sequencing: bind and then] >>=, >>
	\Li[application, strict apl., sequencing] \$, \$!, seq
\end{Ldesc}

\noindent
NOTE: Highest precedence (first line) is 9, lowest precedence is 0.  Those
aligned to the right are right associative, all others left associative: except
comparisons, list membership and list difference which are non-associative.  Default is
\C{infixl 9}.

\subsubsection{Defining fixity}
\begin{ldesc}
	\li[non associative fixity] infix \I{0-9} \I{`op`}
	\li[left associative fixity] infixl \I{0-9} \I{+--+}
	\li[right associative fixity] infixr \I{0-9} \I{-!-}
	\li[default, implied when no fixity given] infixl 9
\end{ldesc}

\subsection{Functions $\equiv$ Infix operators}

\begin{tabular}{CC}
	\li[f a b]         a `f` b
	\li[a + b]         (+) a b
	\li[(a +) b]       ((+) a) b
	\li[(+ b) a]       (\verb+\x+ -> ((+) x b)) a
\end{tabular}


\section{Common functions}

\subsection{Lists}

\begin{tabular}{@{}C@{\s}CC}
	% TODO: Move id from here
	head    & ::\s{}[a] -> a           & head [5,4,3,6] \I{\s= 5}           \\
	tail    & ::\s{}[a] -> [a]         & tail [5,4,3,6] \I{\s= [4,3,6]}     \\
	init    & ::\s{}[a] -> [a]         & init [5,4,3,6] \I{\s= [5,4,3]}     \\[-1pt]
	init xs & \s\s \textnormal{\I{init}ial elements of xs}& \s\s\textnormal{(excludes last element)} \\
	reverse & ::\s{}[a] -> [a]         & reverse [1,3,7] \I{\s= [7,3,1]}    \\
	take    & ::\s{}Int -> [a] -> [a]  & take 2 [5,4,3,6] \I{\s= [5,4]}     \\
	drop    & ::\s{}Int -> [a] -> [a]  & drop 2 [5,4,3,6] \I{\s= [3,6]}     \\
	null    & ::\s{}[a] -> Bool        & null []  \I{\s= True} \s-- emptiness \\
	length  & ::\s{}[a] -> Int         & length [5,4,3,6] \I{\s= 4}         \\
	elem    & ::\s{}a -> [a] -> Bool   & 'a' `elem` "bad" \I{\s= True}      \\
	cycle   & ::\s{}[a] -> [a]         & cycle [1,2,3] \I{\s= [1,2,3,1,2,3...} \\[-1pt] % ]
	cycle xs& \s\textnormal{infinite repetition of \C{xs}} & \\
%	sort
%   zip
\end{tabular}


\subsection{Ord Class}

\begin{tabular}{C@{\s}CC}
	min     & ::\s{}Ord a => a -> a -> a & min 'a' 'b'    \I{\s= 'a'} \\
	max     & ::\s{}Ord a => a -> a -> a & max "b" "ab" \I{\s= "b"}   \\
	compare & ::\s{}Ord a => a -> a -> Ordering & compare 1 2 \I{\s= LT}   \\
\end{tabular}

\subsection{Special folds}

\begin{tabular}{@{}C@{\s}C@{\hspace{1ex}}R@{\s$\equiv$\s}C}
	and     & ::~[Bool]~->~Bool    & and [p,q,r]     & p~\&\&~q~\&\&~r \\
	or      & ::~[Bool]~->~Bool    & or [p,q,r]      & p~||~q~||~r \\
	sum     & ::~Num~a~=>~[a]~->~a & sum [i,j,k]     & i + j + k \\
	product & ::~Num~a~=>~[a]~->~a & product [i,j,k] & i * j * k \\
	concat  & ::~[[a]]~->[a]       & concat [xs,ys,zs] & xs ++ ys ++ zs \\
	maximum & ::~Ord~a=>[a]->a     & maximum [10,0,5] & 10 \\
	minimum & ::~Ord~a=>[a]->a     & minimum [10,0,5] & 0 \\
%	\li[and of booleans in \C{xs}]      and xs
%	\li[or of booleans in \C{xs}]       or xs
%	\li[sum of numbers in \C{xs}]       sum xs
%	\li[product of numbers in \C{xs}]   product xs
%	\li[concatenates list of lists \C{xs}] concat xs
%	\li[largest element in \C{xs}]      maximum xs
%	\li[smallest element in \C{xs}]     minimum xs
\end{tabular}


\subsection{Misc / Tuples}

\begin{tabular}{C@{\s}CC}
	id        & ::\s{}a -> a      & id 1337 \I{\s= 1337} \s-- identity \\
	const     & ::\s{}a -> b -> a & \textnormal{Return first parameter, constant func.} \\
	undefined & ::\s{}a           & \textnormal{lifts error} \\
	fst  & ::\s{}(a, b) -> a     & fst ('a',1) \I{\s= 'a'} \\
	snd  & ::\s{}(a, b) -> b     & snd ('a',1) \I{\s= 1} \\
%	swap & ::\s{}(a, b) -> (b, a) & swap (1,2) \I{\s= (2,1)} -- Data.Tuple \\
\end{tabular}


\subsection{Higher-order / Functors}

\begin{tabular}{C@{\s}C}
	map                 & ::\s{}(a->b) -> [a] -> [b] \\
	map f xs            & \textnormal{apply \C{f} to each \C{x} in \C{xs} returning new list} \\
    map (==4) [5,4,3,6] & \I{\s= [False,True,False,False]} \\[3pt]

	filter              & ::\s{}(a -> Bool) -> [a] -> [a] \\[3pt]

	foldl               & ::\s{}(a -> b -> a) -> a -> [b] -> a \\
	foldl f z xs        & \textnormal{fold - (z `f` left) `to` right} \\
    foldl (+) 0 [5,4,3,6] & \I{\s= ((((0+5)+4)+3)+6) = 18} \\[3pt]

	foldr               & ::\s{}(a -> b -> b) -> b -> [a] -> b \\
	foldr f z xs        & \textnormal{fold - right `to` (left `f` z)} \\
    foldr (+) 0 [5,4,3,6] & \I{\s= 5+(4+(3+(6+0))) = 18} \\
\end{tabular}

%\begin{verbatim}
%foldr :: (a->b->b) -> b -> [a] -> [b]
%                       foldr (+) 0 [5,4,3,6] = 5+(4+(3+(6+0))) = 18
%                       foldr (.) id [tail,tail] [5,4,3,6] = [3,6]
%zipWith (a->b->c) [a] -> [b] -> [c]
%                       zipWith elem ['a','b','c'] ["ab","ca"] = [True,False]
%and :: [Bool] -> Bool
%                       and = foldr (&&) True
%\end{verbatim}



\subsection{IO \normalsize -- Must be ``inside'' the IO Monad}

\begin{ldesc}
	\li[Write char \C{c} to stdout]                      putChar c
	\li[Write string \C{cs} to stdout]                   putStr cs
	\li[... \C{cs} ... with a newline]                   putStrLn cs
	\li[Print \C{x}, a \C{show} instance$^2$, to stdout] print x
	\li[Read char from stdin]                            getChar
	\li[Read line from stdin as a string]                getLine
	\li[Read all input from stdin as a string]           getContents
	\li[Make foo process the input]                      interact foo \li
	                                                     \s\s\small{}:: (String -> String) -> IO ()
	\li[Write char \C{c} to channel/file \C{h}]          hPutChar h c
	\li[Write string \C{cs} to channel/file \C{h}]       hPutStr h cs
	\li[... \C{cs} ... with a newline ... to \C{h}]      hPutStrLn h cs
\end{ldesc}


\section{Pattern Matching}

\subsection{Simple Pattern Matching}

\begin{ldesc}
	\li[Number 3]      3
	\li[Character 'a'] 'a'
	\li[Empty string]  ""
\end{ldesc}

\subsection{List Pattern Matching}

\begin{ldesc}
	\li[head \C{x} and tail \C{xs}]  (x:xs)
	\li[empty list]                  []
	\li[list with 3 elements \C{a}, \C{b} and \C{c}]  [a,b,c]
	\li[list with 3 elements \C{a}, \C{b} and \C{c}]  (a:b:c:[])
	\li[list where 2nd element is 3] (x:3:xs)
\end{ldesc}


\subsection{Other Types Pattern Matching}

\begin{ldesc}
	\li[pair values \C{a} and \C{b}]           (a,b)
	\li[triple values \C{a}, \C{b} and \C{c}]  (a,b,c)
	\li[just constructor]                      Just a
	\li[nothing constructor]                   Nothing
	\li[user-defined type]                     MyData a b c
\end{ldesc}


\subsection{Wildcard Pattern ``Matching''}

\begin{ldesc}
	\li[ignore value]                      \verb+_+
	\li[ignore first elements of list]     (\verb+_+:xs)
	\li[ignore second element of tuple]    (a,\verb+_+)
	\li[ignore one of the ``componenet'']  MyData a \verb+_+ c
\end{ldesc}


\subsection{Nested Pattern}

\begin{ldesc}
	\li[match first tuple on list]  ((a,b):xs)
	\li[match list inside tuple]    (xs,y:ys,zs)
\end{ldesc}


\subsection{As-pattern}

\begin{ldesc}
	\li[match entire tuple \C{s} its values \C{a,b}]            s@(a,b)
	\li[match entire list \C{a} its head \C{x} and tail \C{xs}] a@(x:xs)
	\li[entire data \C{p} and ``components'']                   p@(MyData a b c)
\end{ldesc}



%\section{List Comprehensions}
%
%\begin{ldesc}
%	\li[pairs where sum=4] [(x,y) | \li
%	                       \s\s{}x <- [0..4], \li
%						   \s\s{}y <- [0..4], \li
%						   \s\s{}x + y == 4]  \li
%	                       == [(0,4),(1,3),(2,2),...]
%\end{ldesc}


\section{Expressions (Eval. control)}

\begin{ldesc}
	\li[statement separator]         ;\s\s\s\s-- or line break
	\li[statement grouping]          \verb+{ }+\s\s-- or layout/indentation
	\lI[if expression]
		if\s\I{expr}\s\textcolor{gray}{::\s{}Bool} \li
		\s\s{}then\s\I{expr} \textcolor{gray}{::\s{}a} \li
		\s\s{}else\s\I{expr} \textcolor{gray}{::\s{}a}

	\lI[case expression]
		case\s\I{expr}\s{}of     \li
		\s\s{}\I{pat}\s->\s{}\I{expr}   \li
		\s\s{}\I{pat}\s->\s{}\I{expr}   \li
		\s\s... \li
		\s\s{}\I{\_}\s->\s{}\I{expr}

	\lI[let expression]
		let\s\I{name}=\I{expr} \li
		\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s... \li
		in\s\I{expr}

	\lI[where notation]
		\I{expr} \li
		where\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s\I{name}=\I{expr} \li
		\s\s\s\s\s\s...

	\lI[do notation]
		do      \I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}\I{statement} \li
		\s\s\s{}\I{pat} <- \I{exp} \li
		\s\s\s{}...

	\lI[pattern matching]
		f\s::\s{}a -> b -> c \li[\s{}\I{(case sugar)}]
		f pat pat = expr \li
		f \verb+_+\s\s{} pat = expr \li
		f pat \verb+_+\s\s{} = expr \li
		f \verb+_+\s\s{} \verb+_+\s\s{} = expr
	
	\lI[guarded equations]
		\I{name} \li
		\s\s| \I{boolexpr} = \I{expr} \li
		\s\s| \I{boolexpr} = \I{expr} \li
		\s\s| \I{boolexpr} = \I{expr}
\end{ldesc}


\section{Libraries / Modules}

\begin{ldesc}
	\li[importing]              import \I{PathTo.Lib}
	\li[importing (qualified)]  import \I{PathTo.Lib} as \I{PL}
	\li[importing (subset)]     import \I{PathTo.Lib} (\I{foo},\I{goo})
	\li[declaring]
		module \I{Module.Name} \li
		\s\s( \I{foo} \li
		\s\s, \I{goo} \li
		\s\s) \li
		where \li
	    ...
	\lI[./File/On/Disk.hs] import File.On.Disk
\end{ldesc}


\subsection{QuickCheck \hfill \C{Test.Quickcheck}}

\begin{ldesc}
	\li[declaring property]
		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Bool %\li
%		\I{prop\_something} ::\s{}\I{a}\s{}->\s{}Property
	\li[verifying property]
		quickCheck \I{prop\_something}
\end{ldesc}

%\subsection{SmallCheck \hfill \C{Test.SmallCheck}}

%\begin{ldesc}
%	\li[verifying property]
%		smallCheck \I{depth} \I{prop\_something}
%\end{ldesc}


\subsection{HUnit \hfill \C{Test.HUnit}}

\begin{ldesc}
	\li[equality assertion] \I{expected} \~{}=?\s\I{actual}
	\li[testlist]           \I{mytestlist} = \li
							\s\s{}TestList\s{}[ \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} \li
						\s\s\s\s\s\s\s\s\s\s\s... \li
						\s\s\s\s\s\s\s\s\s\s\s, \I{expec} \~{}=?\s\I{actual} ]
	\li[running tests]      runTestTT \I{mytestlist}
\end{ldesc}


\subsection{Tracing and monitoring (unsafe) \hfill \C{Debug.Trace}}

\begin{ldesc}
	\li[Print \I{string}, eval'n'return \I{expr}] trace \I{string} \$ \I{expr}
	\li[Show and print value]                traceShow \I{expr} \$ \I{expr}
\end{ldesc}
\begin{ldesc}
	\li[Trace function]  fun x y | traceShow (x,y) False = undefined \li[\s call values]
	                     fun x y = ...
\end{ldesc}


\section{Language Pragmas}

\begin{ldesc}
	\li[Activating some pragma]      \verb+{+-\# LANGUAGE \I{SomePragma} \#-\verb+}+
	\li[Same, via GHC call]          ghc -X\I{SomePragma} ...
	\li[No monomorphism restriction] NoMonomorphismRestriction
	\li[Scoped type variables]       ScopedTypeVariables
	\li[Template Haskell]            TemplateHaskell
	\li[GHC option via pragma]       \verb+{+-\# OPTIONS\_GHC \I{-parameter} \#-\verb+}+ 
\end{ldesc}


\section{GHC - Glasgow Haskell Compiler}

\begin{ldesc}
	\li[compiling \C{program.hs}] \$ ghc program.hs
	\li[running]                  \$ ./program
	\li[running directly]         \$ run\_haskell program.hs
	\li[interactive mode (GHCi)]  \$ ghci
	\li[GHCi load]                \verb+>+ :l \I{program.hs}
	\li[GHCi reload]              \verb+>+ :r \I{program.hs}
	\li[GHCi activate stats]      \verb+>+ :set +s
	\li[GHCi turn off stats]      \verb+>+ :unset +s
	\li[GHCi help]                \verb+>+ :?
	\li[Type of an expression]    \verb+>+ :t \I{expr}
	\li[Info (oper./func./class)] \verb+>+ :i \I{thing}
	\li[Installed packages]       \$ ghc-pkg list
	\li[Installed versions of \C{package}] \$ ghc-pkg list package
\end{ldesc}


\section{Cabal package and build system}

\begin{ldesc}
	\li[install package \C{pkg}]                    \$ cabal install \I{pkg}
	\li[update package list]                        \$ cabal update
	\li[list/search for packages matching \C{pat}]  \$ cabal list \I{pat}
	\li[information about package \C{pkg}]          \$ cabal info \I{pkg}
	\li[help on commands]                           \$ cabal help \I{[command]}
\end{ldesc}

\end{document} 

